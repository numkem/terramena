#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/terramena'

require 'optparse'

DEFAULT_SSH_CONFIG_FILENAME = './ssh_config'
DEFAULT_OPTIONS = {
  state: './terraform.tfstate',
  ssh_config: '',
  username: 'root'
}.freeze

options = DEFAULT_OPTIONS.dup
OptionParser.new do |opt|
  opt.on('-s', '--state FILENAME', 'Fullpath to the terraform state file') do |o|
    options[:state] = DEFAULT_OPTIONS[:state] if o == ''

    options[:state] = File.realpath(o)
  end

  opt.on('-c', '--sshconfig FILENAME', 'Fullpath to the ssh_config file') do |o|
    options[:ssh_config] = File.realpath(o)
  end

  opt.on('-u', '--user USERNAME', 'Username to use for SSH') do |o|
    options[:username] = o
  end

  opt.on('-i', '--keyfile KEY_FILE', 'Key file to use during connection') do |o|
    options[:key_file] = o
  end

  opt.on('-v', '--verbose', 'Make SSH talk more') do |o|
    options[:verbose] = o
  end

  opt.on('--debug', 'Add debugging information') do |_o|
    options[:debug] = true
  end
end.parse!

###
### Main
###
if ARGV.empty?
  warn 'a hostname is required as first argument'
  exit 1
end

# Parse arguments
options[:ssh_config] = File.realpath(DEFAULT_SSH_CONFIG_FILENAME) if options[:ssh_config] == ''

hostname = ARGV[0]
username = options[:username]

username, hostname = hostname.split('@') if hostname.include? '@'

terramena = Terramena::Terraform.new(options[:state])
nixos_hosts = terramena.nixos_hosts()
ssh_switches = []

# Check if the hostname matches any hosts in the found nixos_hosts
nixos_hosts.each do |host|
  next unless host.hostname == hostname

  ssh_switches = ['-F', options[:ssh_config]] if options.key? :ssh_config
  ssh_switches += ['-i', options[:key_file]] if options.key? :key_file

  cmd = "ssh #{'-v ' if options[:verbose]}#{ssh_switches.join(' ')} #{username}@#{host.ip}"
  puts "Running ssh command: #{cmd}" if options[:debug]
  exec(cmd)
end

warn "cannot find hostname #{hostname} in nixos hosts"
exit 1
