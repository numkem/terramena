#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/terraform'

require 'optparse'

DEFAULT_OPTIONS = {
  state: './terraform.tfstate',
  ssh_config: './ssh_config',
  username: 'root'
}.freeze

options = DEFAULT_OPTIONS.dup
OptionParser.new do |opt|
  opt.on('-s', '--state FILENAME', 'Fullpath to the terraform state file') do |o|
    options[:state] = DEFAULT_OPTIONS[:state] if o == ''

    options[:state] = File.realpath(o)
  end

  opt.on('-c', '--sshconfig FILENAME', 'Fullpath to the ssh_config file') do |o|
    if o == ''
      ssh_config = File.realpath(DEFAULT_OPTIONS[:ssh_config])

      options[:ssh_config] = ssh_config unless File.exist? ssh_config
    else
      options[:ssh_config] = File.realpath(o)
    end
  end

  opt.on('-u', '--user USERNAME', 'Username to use for SSH') do |o|
    options[:username] = o
  end

  opt.on('-i', '--keyfile KEY_FILE', 'Key file to use during connection') do |o|
    options[:key_file] = o
  end

  opt.on('-v', '--verbose', 'Make SSH talk more') do |o|
    options[:verbose] = o
  end

  opt.on('--debug', 'Add debugging information') do |_o|
    options[:debug] = true
  end
end.parse!

###
### Main
###
if ARGV.empty?
  warn 'a hostname is required as first arugment'
  exit 1
end

hostname = ARGV[0]
username = options[:username]

username, hostname = hostname.split('@') if hostname.include? '@'

terramethod = Terramethod::Terraform.new(options[:state])
nixos_hosts = terramethod.nixos_hosts()
ssh_switches = []

# Check if the hostname matches any hosts in the found nixos_hosts
nixos_hosts.each do |host|
  next unless host.hostname == hostname

  ssh_switches = ['-F', options[:ssh_config]] if options.key? :ssh_config
  ssh_switches += ['-i', options[:key_file]] if options.key? :key_file

  cmd = "ssh #{'-v ' if options[:verbose]}#{ssh_switches.join(' ')} #{username}@#{host.ip}"
  puts "Running ssh command: #{cmd}" if options[:debug]
  exec(cmd)
end

warn "cannot find hostname #{hostname} in nixos hosts"
exit 1
