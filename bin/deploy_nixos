#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/terramena'

require 'English'
require 'optparse'
require 'logger'
require 'json'

DEFAULT_OPTIONS = {
  ssh_config: Terramena::DEFAULT_SSH_CONFIG_FILENAME,
  state: Terramena::DEFAULT_TERRAFORM_STATE_PATH,
  channel_file: Terramena::DEFAULT_CHANNEL_FILENAME,
  extra_paths: [],
  tags: []
}.freeze

options = DEFAULT_OPTIONS.dup

OptionParser.new do |opt|
  opt.on('-t', '--tags TAGS', "Tags to deploy with colmena (separated by ',')") do |o|
    options[:tags] = o.split(',')
  end

  opt.on('-s', '--state FILENAME', 'Fullpath to the terraform state file') do |o|
    options[:state] = DEFAULT_OPTIONS[:state] if o == ''

    options[:state] = File.absolute_path(o)
  end

  opt.on('-c', '--sshconfig FILENAME', 'Fullpath to the ssh_config file') do |o|
    options[:ssh_config] = o
  end

  opt.on('-m', '--module PATH', 'Path to the nixos module root') do |o|
    options[:module_path] = File.absolute_path(o)
  end

  opt.on('-x', '--channel PATH', 'Path to the channel file to use') do |o|
    options[:channel_file] = File.absolute_path(o)
  end

  opt.on('-p', '--paths PATHS', 'List of extra paths to copy to the module_root (seperated by a comma)') do |o|
    options[:extra_paths] = o.split(',')
  end

  opt.on('--no-substitutes', 'Do not use substitution when pushing the new configuration') do |_o|
    options[:no_substitution] = true
  end

  opt.on('--debug', 'Print debugging information') do |_o|
    options[:debug] = true
  end

  opt.on('--show-trace', 'Show trace of nix build') do |_o|
    options[:show_trace] = true
  end
end.parse!

logger = Logger.new($stdout)
logger.formatter = proc do |severity, _datetime, _progname, msg|
  "[#{severity}]: #{msg}\n"
end
logger.level = if options[:debug]
                 Logger::DEBUG
               else
                 Logger::WARN
               end

# Set the logger for each modules
Terramena.logger = logger

# Some options have to be validated, they cannot contain a bad value
#
# Check if the current path contains a file named ssh_config
if File.exist? options[:ssh_config]
  # If it does, use it
  options[:ssh_config] = File.realpath options[:ssh_config]
else
  options[:ssh_config] = ''
  warn 'warning: no ssh_config file provided'
end

# Channel file is required, if it's not found we error out
if File.exist? options[:channel_file]
  options[:channel_file] = File.realpath options[:channel_file]
else
  warn 'required channel file missing'
  exit 1
end

logger.debug "options: #{options}"

# Parse commands
if ARGV.empty?
  goal = 'apply'
else
  case ARGV[0]
  when 'list'
    t = Terramena::Colmena.new('', options[:tags], [])
    t.list(options[:terraform_state_path], options[:tags])
    exit 0
  when 'apply'
    # Default behavior
    goal = 'apply'
  when 'boot'
    goal = 'apply'
  else
    warn "command '#{ARGV[0]}' does not exist, [list|apply] supported"
    exit 1
  end
end

begin
  colmena = Terramena::Colmena.new(options[:module_path], options[:tags], options[:extra_paths],
                                   options = { terraform_state_path: options[:state],
                                               ssh_config: options[:ssh_config],
                                               channel_filename: options[:channel_filename] })
  colmena.deploy(goal, show_trace: options[:show_trace], no_substitutes: options[:no_substitutes])
ensure
  colmena.cleanup
end

# Local Variables:
# mode: ruby
# End:
